{"ast":null,"code":"import { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport { getEnumValues } from \"./util.js\";\nexport class JSONSchemaGenerator {\n  constructor(params) {\n    this.counter = 0;\n    this.metadataRegistry = params?.metadata ?? globalRegistry;\n    this.target = params?.target ?? \"draft-2020-12\";\n    this.unrepresentable = params?.unrepresentable ?? \"throw\";\n    this.override = params?.override ?? (() => {});\n    this.io = params?.io ?? \"output\";\n    this.seen = new Map();\n  }\n  process(schema, _params = {\n    path: [],\n    schemaPath: []\n  }) {\n    var _a;\n    const def = schema._zod.def;\n    const formatMap = {\n      guid: \"uuid\",\n      url: \"uri\",\n      datetime: \"date-time\",\n      json_string: \"json-string\",\n      regex: \"\" // do not set\n    };\n    // check for schema in seens\n    const seen = this.seen.get(schema);\n    if (seen) {\n      seen.count++;\n      // check if cycle\n      const isCycle = _params.schemaPath.includes(schema);\n      if (isCycle) {\n        seen.cycle = _params.path;\n      }\n      return seen.schema;\n    }\n    // initialize\n    const result = {\n      schema: {},\n      count: 1,\n      cycle: undefined,\n      path: _params.path\n    };\n    this.seen.set(schema, result);\n    // custom method overrides default behavior\n    const overrideSchema = schema._zod.toJSONSchema?.();\n    if (overrideSchema) {\n      result.schema = overrideSchema;\n    } else {\n      const params = {\n        ..._params,\n        schemaPath: [..._params.schemaPath, schema],\n        path: _params.path\n      };\n      const parent = schema._zod.parent;\n      if (parent) {\n        // schema was cloned from another schema\n        result.ref = parent;\n        this.process(parent, params);\n        this.seen.get(parent).isParent = true;\n      } else {\n        const _json = result.schema;\n        switch (def.type) {\n          case \"string\":\n            {\n              const json = _json;\n              json.type = \"string\";\n              const {\n                minimum,\n                maximum,\n                format,\n                patterns,\n                contentEncoding\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minLength = minimum;\n              if (typeof maximum === \"number\") json.maxLength = maximum;\n              // custom pattern overrides format\n              if (format) {\n                json.format = formatMap[format] ?? format;\n                if (json.format === \"\") delete json.format; // empty format is not valid\n              }\n              if (contentEncoding) json.contentEncoding = contentEncoding;\n              if (patterns && patterns.size > 0) {\n                const regexes = [...patterns];\n                if (regexes.length === 1) json.pattern = regexes[0].source;else if (regexes.length > 1) {\n                  result.schema.allOf = [...regexes.map(regex => ({\n                    ...(this.target === \"draft-7\" ? {\n                      type: \"string\"\n                    } : {}),\n                    pattern: regex.source\n                  }))];\n                }\n              }\n              break;\n            }\n          case \"number\":\n            {\n              const json = _json;\n              const {\n                minimum,\n                maximum,\n                format,\n                multipleOf,\n                exclusiveMaximum,\n                exclusiveMinimum\n              } = schema._zod.bag;\n              if (typeof format === \"string\" && format.includes(\"int\")) json.type = \"integer\";else json.type = \"number\";\n              if (typeof exclusiveMinimum === \"number\") json.exclusiveMinimum = exclusiveMinimum;\n              if (typeof minimum === \"number\") {\n                json.minimum = minimum;\n                if (typeof exclusiveMinimum === \"number\") {\n                  if (exclusiveMinimum >= minimum) delete json.minimum;else delete json.exclusiveMinimum;\n                }\n              }\n              if (typeof exclusiveMaximum === \"number\") json.exclusiveMaximum = exclusiveMaximum;\n              if (typeof maximum === \"number\") {\n                json.maximum = maximum;\n                if (typeof exclusiveMaximum === \"number\") {\n                  if (exclusiveMaximum <= maximum) delete json.maximum;else delete json.exclusiveMaximum;\n                }\n              }\n              if (typeof multipleOf === \"number\") json.multipleOf = multipleOf;\n              break;\n            }\n          case \"boolean\":\n            {\n              const json = _json;\n              json.type = \"boolean\";\n              break;\n            }\n          case \"bigint\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"BigInt cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"symbol\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Symbols cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"null\":\n            {\n              _json.type = \"null\";\n              break;\n            }\n          case \"any\":\n            {\n              break;\n            }\n          case \"unknown\":\n            {\n              break;\n            }\n          case \"undefined\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Undefined cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"void\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Void cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"never\":\n            {\n              _json.not = {};\n              break;\n            }\n          case \"date\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Date cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"array\":\n            {\n              const json = _json;\n              const {\n                minimum,\n                maximum\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minItems = minimum;\n              if (typeof maximum === \"number\") json.maxItems = maximum;\n              json.type = \"array\";\n              json.items = this.process(def.element, {\n                ...params,\n                path: [...params.path, \"items\"]\n              });\n              break;\n            }\n          case \"object\":\n            {\n              const json = _json;\n              json.type = \"object\";\n              json.properties = {};\n              const shape = def.shape; // params.shapeCache.get(schema)!;\n              for (const key in shape) {\n                json.properties[key] = this.process(shape[key], {\n                  ...params,\n                  path: [...params.path, \"properties\", key]\n                });\n              }\n              // required keys\n              const allKeys = new Set(Object.keys(shape));\n              // const optionalKeys = new Set(def.optional);\n              const requiredKeys = new Set([...allKeys].filter(key => {\n                const v = def.shape[key]._zod;\n                if (this.io === \"input\") {\n                  return v.optin === undefined;\n                } else {\n                  return v.optout === undefined;\n                }\n              }));\n              if (requiredKeys.size > 0) {\n                json.required = Array.from(requiredKeys);\n              }\n              // catchall\n              if (def.catchall?._zod.def.type === \"never\") {\n                // strict\n                json.additionalProperties = false;\n              } else if (!def.catchall) {\n                // regular\n                if (this.io === \"output\") json.additionalProperties = false;\n              } else if (def.catchall) {\n                json.additionalProperties = this.process(def.catchall, {\n                  ...params,\n                  path: [...params.path, \"additionalProperties\"]\n                });\n              }\n              break;\n            }\n          case \"union\":\n            {\n              const json = _json;\n              json.anyOf = def.options.map((x, i) => this.process(x, {\n                ...params,\n                path: [...params.path, \"anyOf\", i]\n              }));\n              break;\n            }\n          case \"intersection\":\n            {\n              const json = _json;\n              const a = this.process(def.left, {\n                ...params,\n                path: [...params.path, \"allOf\", 0]\n              });\n              const b = this.process(def.right, {\n                ...params,\n                path: [...params.path, \"allOf\", 1]\n              });\n              const isSimpleIntersection = val => \"allOf\" in val && Object.keys(val).length === 1;\n              const allOf = [...(isSimpleIntersection(a) ? a.allOf : [a]), ...(isSimpleIntersection(b) ? b.allOf : [b])];\n              json.allOf = allOf;\n              break;\n            }\n          case \"tuple\":\n            {\n              const json = _json;\n              json.type = \"array\";\n              const prefixItems = def.items.map((x, i) => this.process(x, {\n                ...params,\n                path: [...params.path, \"prefixItems\", i]\n              }));\n              if (this.target === \"draft-2020-12\") {\n                json.prefixItems = prefixItems;\n              } else {\n                json.items = prefixItems;\n              }\n              if (def.rest) {\n                const rest = this.process(def.rest, {\n                  ...params,\n                  path: [...params.path, \"items\"]\n                });\n                if (this.target === \"draft-2020-12\") {\n                  json.items = rest;\n                } else {\n                  json.additionalItems = rest;\n                }\n              }\n              // additionalItems\n              if (def.rest) {\n                json.items = this.process(def.rest, {\n                  ...params,\n                  path: [...params.path, \"items\"]\n                });\n              }\n              // length\n              const {\n                minimum,\n                maximum\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minItems = minimum;\n              if (typeof maximum === \"number\") json.maxItems = maximum;\n              break;\n            }\n          case \"record\":\n            {\n              const json = _json;\n              json.type = \"object\";\n              json.propertyNames = this.process(def.keyType, {\n                ...params,\n                path: [...params.path, \"propertyNames\"]\n              });\n              json.additionalProperties = this.process(def.valueType, {\n                ...params,\n                path: [...params.path, \"additionalProperties\"]\n              });\n              break;\n            }\n          case \"map\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Map cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"set\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Set cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"enum\":\n            {\n              const json = _json;\n              const values = getEnumValues(def.entries);\n              // Number enums can have both string and number values\n              if (values.every(v => typeof v === \"number\")) json.type = \"number\";\n              if (values.every(v => typeof v === \"string\")) json.type = \"string\";\n              json.enum = values;\n              break;\n            }\n          case \"literal\":\n            {\n              const json = _json;\n              const vals = [];\n              for (const val of def.values) {\n                if (val === undefined) {\n                  if (this.unrepresentable === \"throw\") {\n                    throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                  } else {\n                    // do not add to vals\n                  }\n                } else if (typeof val === \"bigint\") {\n                  if (this.unrepresentable === \"throw\") {\n                    throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                  } else {\n                    vals.push(Number(val));\n                  }\n                } else {\n                  vals.push(val);\n                }\n              }\n              if (vals.length === 0) {\n                // do nothing (an undefined literal was stripped)\n              } else if (vals.length === 1) {\n                const val = vals[0];\n                json.type = val === null ? \"null\" : typeof val;\n                json.const = val;\n              } else {\n                if (vals.every(v => typeof v === \"number\")) json.type = \"number\";\n                if (vals.every(v => typeof v === \"string\")) json.type = \"string\";\n                if (vals.every(v => typeof v === \"boolean\")) json.type = \"string\";\n                if (vals.every(v => v === null)) json.type = \"null\";\n                json.enum = vals;\n              }\n              break;\n            }\n          case \"file\":\n            {\n              const json = _json;\n              const file = {\n                type: \"string\",\n                format: \"binary\",\n                contentEncoding: \"binary\"\n              };\n              const {\n                minimum,\n                maximum,\n                mime\n              } = schema._zod.bag;\n              if (minimum !== undefined) file.minLength = minimum;\n              if (maximum !== undefined) file.maxLength = maximum;\n              if (mime) {\n                if (mime.length === 1) {\n                  file.contentMediaType = mime[0];\n                  Object.assign(json, file);\n                } else {\n                  json.anyOf = mime.map(m => {\n                    const mFile = {\n                      ...file,\n                      contentMediaType: m\n                    };\n                    return mFile;\n                  });\n                }\n              } else {\n                Object.assign(json, file);\n              }\n              // if (this.unrepresentable === \"throw\") {\n              //   throw new Error(\"File cannot be represented in JSON Schema\");\n              // }\n              break;\n            }\n          case \"transform\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Transforms cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"nullable\":\n            {\n              const inner = this.process(def.innerType, params);\n              _json.anyOf = [inner, {\n                type: \"null\"\n              }];\n              break;\n            }\n          case \"nonoptional\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"success\":\n            {\n              const json = _json;\n              json.type = \"boolean\";\n              break;\n            }\n          case \"default\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n              break;\n            }\n          case \"prefault\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              if (this.io === \"input\") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n              break;\n            }\n          case \"catch\":\n            {\n              // use conditionals\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              let catchValue;\n              try {\n                catchValue = def.catchValue(undefined);\n              } catch {\n                throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n              }\n              _json.default = catchValue;\n              break;\n            }\n          case \"nan\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"NaN cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"template_literal\":\n            {\n              const json = _json;\n              const pattern = schema._zod.pattern;\n              if (!pattern) throw new Error(\"Pattern not found in template literal\");\n              json.type = \"string\";\n              json.pattern = pattern.source;\n              break;\n            }\n          case \"pipe\":\n            {\n              const innerType = this.io === \"input\" ? def.in._zod.def.type === \"transform\" ? def.out : def.in : def.out;\n              this.process(innerType, params);\n              result.ref = innerType;\n              break;\n            }\n          case \"readonly\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              _json.readOnly = true;\n              break;\n            }\n          // passthrough types\n          case \"promise\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"optional\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"lazy\":\n            {\n              const innerType = schema._zod.innerType;\n              this.process(innerType, params);\n              result.ref = innerType;\n              break;\n            }\n          case \"custom\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Custom types cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          default:\n            {\n              def;\n            }\n        }\n      }\n    }\n    // metadata\n    const meta = this.metadataRegistry.get(schema);\n    if (meta) Object.assign(result.schema, meta);\n    if (this.io === \"input\" && isTransforming(schema)) {\n      // examples/defaults only apply to output type of pipe\n      delete result.schema.examples;\n      delete result.schema.default;\n    }\n    // set prefault as default\n    if (this.io === \"input\" && result.schema._prefault) (_a = result.schema).default ?? (_a.default = result.schema._prefault);\n    delete result.schema._prefault;\n    // pulling fresh from this.seen in case it was overwritten\n    const _result = this.seen.get(schema);\n    return _result.schema;\n  }\n  emit(schema, _params) {\n    const params = {\n      cycles: _params?.cycles ?? \"ref\",\n      reused: _params?.reused ?? \"inline\",\n      // unrepresentable: _params?.unrepresentable ?? \"throw\",\n      // uri: _params?.uri ?? ((id) => `${id}`),\n      external: _params?.external ?? undefined\n    };\n    // iterate over seen map;\n    const root = this.seen.get(schema);\n    if (!root) throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n    // initialize result with root schema fields\n    // Object.assign(result, seen.cached);\n    // returns a ref to the schema\n    // defId will be empty if the ref points to an external schema (or #)\n    const makeURI = entry => {\n      // comparing the seen objects because sometimes\n      // multiple schemas map to the same seen object.\n      // e.g. lazy\n      // external is configured\n      const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      if (params.external) {\n        const externalId = params.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n        // check if schema is in the external registry\n        const uriGenerator = params.external.uri ?? (id => id);\n        if (externalId) {\n          return {\n            ref: uriGenerator(externalId)\n          };\n        }\n        // otherwise, add to __shared\n        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;\n        entry[1].defId = id; // set defId so it will be reused if needed\n        return {\n          defId: id,\n          ref: `${uriGenerator(\"__shared\")}#/${defsSegment}/${id}`\n        };\n      }\n      if (entry[1] === root) {\n        return {\n          ref: \"#\"\n        };\n      }\n      // self-contained schema\n      const uriPrefix = `#`;\n      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n      return {\n        defId,\n        ref: defUriPrefix + defId\n      };\n    };\n    // stored cached version in `def` property\n    // remove all properties, set $ref\n    const extractToDef = entry => {\n      // if the schema is already a reference, do not extract it\n      if (entry[1].schema.$ref) {\n        return;\n      }\n      const seen = entry[1];\n      const {\n        ref,\n        defId\n      } = makeURI(entry);\n      seen.def = {\n        ...seen.schema\n      };\n      // defId won't be set if the schema is a reference to an external schema\n      if (defId) seen.defId = defId;\n      // wipe away all properties except $ref\n      const schema = seen.schema;\n      for (const key in schema) {\n        delete schema[key];\n      }\n      schema.$ref = ref;\n    };\n    // throw on cycles\n    // break cycles\n    if (params.cycles === \"throw\") {\n      for (const entry of this.seen.entries()) {\n        const seen = entry[1];\n        if (seen.cycle) {\n          throw new Error(\"Cycle detected: \" + `#/${seen.cycle?.join(\"/\")}/<root>` + '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n        }\n      }\n    }\n    // extract schemas into $defs\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      // convert root schema to # $ref\n      if (schema === entry[0]) {\n        extractToDef(entry); // this has special handling for the root schema\n        continue;\n      }\n      // extract schemas that are in the external registry\n      if (params.external) {\n        const ext = params.external.registry.get(entry[0])?.id;\n        if (schema !== entry[0] && ext) {\n          extractToDef(entry);\n          continue;\n        }\n      }\n      // extract schemas with `id` meta\n      const id = this.metadataRegistry.get(entry[0])?.id;\n      if (id) {\n        extractToDef(entry);\n        continue;\n      }\n      // break cycles\n      if (seen.cycle) {\n        // any\n        extractToDef(entry);\n        continue;\n      }\n      // extract reused schemas\n      if (seen.count > 1) {\n        if (params.reused === \"ref\") {\n          extractToDef(entry);\n          // biome-ignore lint:\n          continue;\n        }\n      }\n    }\n    // flatten _refs\n    const flattenRef = (zodSchema, params) => {\n      const seen = this.seen.get(zodSchema);\n      const schema = seen.def ?? seen.schema;\n      const _cached = {\n        ...schema\n      };\n      // already seen\n      if (seen.ref === null) {\n        return;\n      }\n      // flatten ref if defined\n      const ref = seen.ref;\n      seen.ref = null; // prevent recursion\n      if (ref) {\n        flattenRef(ref, params);\n        // merge referenced schema into current\n        const refSchema = this.seen.get(ref).schema;\n        if (refSchema.$ref && params.target === \"draft-7\") {\n          schema.allOf = schema.allOf ?? [];\n          schema.allOf.push(refSchema);\n        } else {\n          Object.assign(schema, refSchema);\n          Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n        }\n      }\n      // execute overrides\n      if (!seen.isParent) this.override({\n        zodSchema: zodSchema,\n        jsonSchema: schema,\n        path: seen.path ?? []\n      });\n    };\n    for (const entry of [...this.seen.entries()].reverse()) {\n      flattenRef(entry[0], {\n        target: this.target\n      });\n    }\n    const result = {};\n    if (this.target === \"draft-2020-12\") {\n      result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n    } else if (this.target === \"draft-7\") {\n      result.$schema = \"http://json-schema.org/draft-07/schema#\";\n    } else {\n      console.warn(`Invalid target: ${this.target}`);\n    }\n    if (params.external?.uri) {\n      const id = params.external.registry.get(schema)?.id;\n      if (!id) throw new Error(\"Schema is missing an `id` property\");\n      result.$id = params.external.uri(id);\n    }\n    Object.assign(result, root.def);\n    // build defs object\n    const defs = params.external?.defs ?? {};\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (seen.def && seen.defId) {\n        defs[seen.defId] = seen.def;\n      }\n    }\n    // set definitions in result\n    if (params.external) {} else {\n      if (Object.keys(defs).length > 0) {\n        if (this.target === \"draft-2020-12\") {\n          result.$defs = defs;\n        } else {\n          result.definitions = defs;\n        }\n      }\n    }\n    try {\n      // this \"finalizes\" this schema and ensures all cycles are removed\n      // each call to .emit() is functionally independent\n      // though the seen map is shared\n      return JSON.parse(JSON.stringify(result));\n    } catch (_err) {\n      throw new Error(\"Error converting schema to JSON.\");\n    }\n  }\n}\nexport function toJSONSchema(input, _params) {\n  if (input instanceof $ZodRegistry) {\n    const gen = new JSONSchemaGenerator(_params);\n    const defs = {};\n    for (const entry of input._idmap.entries()) {\n      const [_, schema] = entry;\n      gen.process(schema);\n    }\n    const schemas = {};\n    const external = {\n      registry: input,\n      uri: _params?.uri,\n      defs\n    };\n    for (const entry of input._idmap.entries()) {\n      const [key, schema] = entry;\n      schemas[key] = gen.emit(schema, {\n        ..._params,\n        external\n      });\n    }\n    if (Object.keys(defs).length > 0) {\n      const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      schemas.__shared = {\n        [defsSegment]: defs\n      };\n    }\n    return {\n      schemas\n    };\n  }\n  const gen = new JSONSchemaGenerator(_params);\n  gen.process(input);\n  return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n  const ctx = _ctx ?? {\n    seen: new Set()\n  };\n  if (ctx.seen.has(_schema)) return false;\n  ctx.seen.add(_schema);\n  const schema = _schema;\n  const def = schema._zod.def;\n  switch (def.type) {\n    case \"string\":\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n    case \"date\":\n    case \"symbol\":\n    case \"undefined\":\n    case \"null\":\n    case \"any\":\n    case \"unknown\":\n    case \"never\":\n    case \"void\":\n    case \"literal\":\n    case \"enum\":\n    case \"nan\":\n    case \"file\":\n    case \"template_literal\":\n      return false;\n    case \"array\":\n      {\n        return isTransforming(def.element, ctx);\n      }\n    case \"object\":\n      {\n        for (const key in def.shape) {\n          if (isTransforming(def.shape[key], ctx)) return true;\n        }\n        return false;\n      }\n    case \"union\":\n      {\n        for (const option of def.options) {\n          if (isTransforming(option, ctx)) return true;\n        }\n        return false;\n      }\n    case \"intersection\":\n      {\n        return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n      }\n    case \"tuple\":\n      {\n        for (const item of def.items) {\n          if (isTransforming(item, ctx)) return true;\n        }\n        if (def.rest && isTransforming(def.rest, ctx)) return true;\n        return false;\n      }\n    case \"record\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"map\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"set\":\n      {\n        return isTransforming(def.valueType, ctx);\n      }\n    // inner types\n    case \"promise\":\n    case \"optional\":\n    case \"nonoptional\":\n    case \"nullable\":\n    case \"readonly\":\n      return isTransforming(def.innerType, ctx);\n    case \"lazy\":\n      return isTransforming(def.getter(), ctx);\n    case \"default\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"prefault\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"custom\":\n      {\n        return false;\n      }\n    case \"transform\":\n      {\n        return true;\n      }\n    case \"pipe\":\n      {\n        return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n      }\n    case \"success\":\n      {\n        return false;\n      }\n    case \"catch\":\n      {\n        return false;\n      }\n    default:\n      def;\n  }\n  throw new Error(`Unknown schema type: ${def.type}`);\n}","map":{"version":3,"names":["$ZodRegistry","globalRegistry","getEnumValues","JSONSchemaGenerator","constructor","params","counter","metadataRegistry","metadata","target","unrepresentable","override","io","seen","Map","process","schema","_params","path","schemaPath","_a","def","_zod","formatMap","guid","url","datetime","json_string","regex","get","count","isCycle","includes","cycle","result","undefined","set","overrideSchema","toJSONSchema","parent","ref","isParent","_json","type","json","minimum","maximum","format","patterns","contentEncoding","bag","minLength","maxLength","size","regexes","length","pattern","source","allOf","map","multipleOf","exclusiveMaximum","exclusiveMinimum","Error","not","minItems","maxItems","items","element","properties","shape","key","allKeys","Set","Object","keys","requiredKeys","filter","v","optin","optout","required","Array","from","catchall","additionalProperties","anyOf","options","x","i","a","left","b","right","isSimpleIntersection","val","prefixItems","rest","additionalItems","propertyNames","keyType","valueType","values","entries","every","enum","vals","push","Number","const","file","mime","contentMediaType","assign","m","mFile","inner","innerType","default","JSON","parse","stringify","defaultValue","_prefault","catchValue","in","out","readOnly","meta","isTransforming","examples","_result","emit","cycles","reused","external","root","makeURI","entry","defsSegment","externalId","registry","id","uriGenerator","uri","defId","uriPrefix","defUriPrefix","extractToDef","$ref","join","ext","flattenRef","zodSchema","_cached","refSchema","jsonSchema","reverse","$schema","console","warn","$id","defs","$defs","definitions","_err","input","gen","_idmap","_","schemas","__shared","_schema","_ctx","ctx","has","add","option","item","getter"],"sources":["/app/frontend/node_modules/zod/v4/core/to-json-schema.js"],"sourcesContent":["import { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport { getEnumValues } from \"./util.js\";\nexport class JSONSchemaGenerator {\n    constructor(params) {\n        this.counter = 0;\n        this.metadataRegistry = params?.metadata ?? globalRegistry;\n        this.target = params?.target ?? \"draft-2020-12\";\n        this.unrepresentable = params?.unrepresentable ?? \"throw\";\n        this.override = params?.override ?? (() => { });\n        this.io = params?.io ?? \"output\";\n        this.seen = new Map();\n    }\n    process(schema, _params = { path: [], schemaPath: [] }) {\n        var _a;\n        const def = schema._zod.def;\n        const formatMap = {\n            guid: \"uuid\",\n            url: \"uri\",\n            datetime: \"date-time\",\n            json_string: \"json-string\",\n            regex: \"\", // do not set\n        };\n        // check for schema in seens\n        const seen = this.seen.get(schema);\n        if (seen) {\n            seen.count++;\n            // check if cycle\n            const isCycle = _params.schemaPath.includes(schema);\n            if (isCycle) {\n                seen.cycle = _params.path;\n            }\n            return seen.schema;\n        }\n        // initialize\n        const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };\n        this.seen.set(schema, result);\n        // custom method overrides default behavior\n        const overrideSchema = schema._zod.toJSONSchema?.();\n        if (overrideSchema) {\n            result.schema = overrideSchema;\n        }\n        else {\n            const params = {\n                ..._params,\n                schemaPath: [..._params.schemaPath, schema],\n                path: _params.path,\n            };\n            const parent = schema._zod.parent;\n            if (parent) {\n                // schema was cloned from another schema\n                result.ref = parent;\n                this.process(parent, params);\n                this.seen.get(parent).isParent = true;\n            }\n            else {\n                const _json = result.schema;\n                switch (def.type) {\n                    case \"string\": {\n                        const json = _json;\n                        json.type = \"string\";\n                        const { minimum, maximum, format, patterns, contentEncoding } = schema._zod\n                            .bag;\n                        if (typeof minimum === \"number\")\n                            json.minLength = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxLength = maximum;\n                        // custom pattern overrides format\n                        if (format) {\n                            json.format = formatMap[format] ?? format;\n                            if (json.format === \"\")\n                                delete json.format; // empty format is not valid\n                        }\n                        if (contentEncoding)\n                            json.contentEncoding = contentEncoding;\n                        if (patterns && patterns.size > 0) {\n                            const regexes = [...patterns];\n                            if (regexes.length === 1)\n                                json.pattern = regexes[0].source;\n                            else if (regexes.length > 1) {\n                                result.schema.allOf = [\n                                    ...regexes.map((regex) => ({\n                                        ...(this.target === \"draft-7\" ? { type: \"string\" } : {}),\n                                        pattern: regex.source,\n                                    })),\n                                ];\n                            }\n                        }\n                        break;\n                    }\n                    case \"number\": {\n                        const json = _json;\n                        const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n                        if (typeof format === \"string\" && format.includes(\"int\"))\n                            json.type = \"integer\";\n                        else\n                            json.type = \"number\";\n                        if (typeof exclusiveMinimum === \"number\")\n                            json.exclusiveMinimum = exclusiveMinimum;\n                        if (typeof minimum === \"number\") {\n                            json.minimum = minimum;\n                            if (typeof exclusiveMinimum === \"number\") {\n                                if (exclusiveMinimum >= minimum)\n                                    delete json.minimum;\n                                else\n                                    delete json.exclusiveMinimum;\n                            }\n                        }\n                        if (typeof exclusiveMaximum === \"number\")\n                            json.exclusiveMaximum = exclusiveMaximum;\n                        if (typeof maximum === \"number\") {\n                            json.maximum = maximum;\n                            if (typeof exclusiveMaximum === \"number\") {\n                                if (exclusiveMaximum <= maximum)\n                                    delete json.maximum;\n                                else\n                                    delete json.exclusiveMaximum;\n                            }\n                        }\n                        if (typeof multipleOf === \"number\")\n                            json.multipleOf = multipleOf;\n                        break;\n                    }\n                    case \"boolean\": {\n                        const json = _json;\n                        json.type = \"boolean\";\n                        break;\n                    }\n                    case \"bigint\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"BigInt cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"symbol\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Symbols cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"null\": {\n                        _json.type = \"null\";\n                        break;\n                    }\n                    case \"any\": {\n                        break;\n                    }\n                    case \"unknown\": {\n                        break;\n                    }\n                    case \"undefined\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Undefined cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"void\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Void cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"never\": {\n                        _json.not = {};\n                        break;\n                    }\n                    case \"date\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Date cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"array\": {\n                        const json = _json;\n                        const { minimum, maximum } = schema._zod.bag;\n                        if (typeof minimum === \"number\")\n                            json.minItems = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxItems = maximum;\n                        json.type = \"array\";\n                        json.items = this.process(def.element, { ...params, path: [...params.path, \"items\"] });\n                        break;\n                    }\n                    case \"object\": {\n                        const json = _json;\n                        json.type = \"object\";\n                        json.properties = {};\n                        const shape = def.shape; // params.shapeCache.get(schema)!;\n                        for (const key in shape) {\n                            json.properties[key] = this.process(shape[key], {\n                                ...params,\n                                path: [...params.path, \"properties\", key],\n                            });\n                        }\n                        // required keys\n                        const allKeys = new Set(Object.keys(shape));\n                        // const optionalKeys = new Set(def.optional);\n                        const requiredKeys = new Set([...allKeys].filter((key) => {\n                            const v = def.shape[key]._zod;\n                            if (this.io === \"input\") {\n                                return v.optin === undefined;\n                            }\n                            else {\n                                return v.optout === undefined;\n                            }\n                        }));\n                        if (requiredKeys.size > 0) {\n                            json.required = Array.from(requiredKeys);\n                        }\n                        // catchall\n                        if (def.catchall?._zod.def.type === \"never\") {\n                            // strict\n                            json.additionalProperties = false;\n                        }\n                        else if (!def.catchall) {\n                            // regular\n                            if (this.io === \"output\")\n                                json.additionalProperties = false;\n                        }\n                        else if (def.catchall) {\n                            json.additionalProperties = this.process(def.catchall, {\n                                ...params,\n                                path: [...params.path, \"additionalProperties\"],\n                            });\n                        }\n                        break;\n                    }\n                    case \"union\": {\n                        const json = _json;\n                        json.anyOf = def.options.map((x, i) => this.process(x, {\n                            ...params,\n                            path: [...params.path, \"anyOf\", i],\n                        }));\n                        break;\n                    }\n                    case \"intersection\": {\n                        const json = _json;\n                        const a = this.process(def.left, {\n                            ...params,\n                            path: [...params.path, \"allOf\", 0],\n                        });\n                        const b = this.process(def.right, {\n                            ...params,\n                            path: [...params.path, \"allOf\", 1],\n                        });\n                        const isSimpleIntersection = (val) => \"allOf\" in val && Object.keys(val).length === 1;\n                        const allOf = [\n                            ...(isSimpleIntersection(a) ? a.allOf : [a]),\n                            ...(isSimpleIntersection(b) ? b.allOf : [b]),\n                        ];\n                        json.allOf = allOf;\n                        break;\n                    }\n                    case \"tuple\": {\n                        const json = _json;\n                        json.type = \"array\";\n                        const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, \"prefixItems\", i] }));\n                        if (this.target === \"draft-2020-12\") {\n                            json.prefixItems = prefixItems;\n                        }\n                        else {\n                            json.items = prefixItems;\n                        }\n                        if (def.rest) {\n                            const rest = this.process(def.rest, {\n                                ...params,\n                                path: [...params.path, \"items\"],\n                            });\n                            if (this.target === \"draft-2020-12\") {\n                                json.items = rest;\n                            }\n                            else {\n                                json.additionalItems = rest;\n                            }\n                        }\n                        // additionalItems\n                        if (def.rest) {\n                            json.items = this.process(def.rest, {\n                                ...params,\n                                path: [...params.path, \"items\"],\n                            });\n                        }\n                        // length\n                        const { minimum, maximum } = schema._zod.bag;\n                        if (typeof minimum === \"number\")\n                            json.minItems = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxItems = maximum;\n                        break;\n                    }\n                    case \"record\": {\n                        const json = _json;\n                        json.type = \"object\";\n                        json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, \"propertyNames\"] });\n                        json.additionalProperties = this.process(def.valueType, {\n                            ...params,\n                            path: [...params.path, \"additionalProperties\"],\n                        });\n                        break;\n                    }\n                    case \"map\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Map cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"set\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Set cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"enum\": {\n                        const json = _json;\n                        const values = getEnumValues(def.entries);\n                        // Number enums can have both string and number values\n                        if (values.every((v) => typeof v === \"number\"))\n                            json.type = \"number\";\n                        if (values.every((v) => typeof v === \"string\"))\n                            json.type = \"string\";\n                        json.enum = values;\n                        break;\n                    }\n                    case \"literal\": {\n                        const json = _json;\n                        const vals = [];\n                        for (const val of def.values) {\n                            if (val === undefined) {\n                                if (this.unrepresentable === \"throw\") {\n                                    throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                                }\n                                else {\n                                    // do not add to vals\n                                }\n                            }\n                            else if (typeof val === \"bigint\") {\n                                if (this.unrepresentable === \"throw\") {\n                                    throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                                }\n                                else {\n                                    vals.push(Number(val));\n                                }\n                            }\n                            else {\n                                vals.push(val);\n                            }\n                        }\n                        if (vals.length === 0) {\n                            // do nothing (an undefined literal was stripped)\n                        }\n                        else if (vals.length === 1) {\n                            const val = vals[0];\n                            json.type = val === null ? \"null\" : typeof val;\n                            json.const = val;\n                        }\n                        else {\n                            if (vals.every((v) => typeof v === \"number\"))\n                                json.type = \"number\";\n                            if (vals.every((v) => typeof v === \"string\"))\n                                json.type = \"string\";\n                            if (vals.every((v) => typeof v === \"boolean\"))\n                                json.type = \"string\";\n                            if (vals.every((v) => v === null))\n                                json.type = \"null\";\n                            json.enum = vals;\n                        }\n                        break;\n                    }\n                    case \"file\": {\n                        const json = _json;\n                        const file = {\n                            type: \"string\",\n                            format: \"binary\",\n                            contentEncoding: \"binary\",\n                        };\n                        const { minimum, maximum, mime } = schema._zod.bag;\n                        if (minimum !== undefined)\n                            file.minLength = minimum;\n                        if (maximum !== undefined)\n                            file.maxLength = maximum;\n                        if (mime) {\n                            if (mime.length === 1) {\n                                file.contentMediaType = mime[0];\n                                Object.assign(json, file);\n                            }\n                            else {\n                                json.anyOf = mime.map((m) => {\n                                    const mFile = { ...file, contentMediaType: m };\n                                    return mFile;\n                                });\n                            }\n                        }\n                        else {\n                            Object.assign(json, file);\n                        }\n                        // if (this.unrepresentable === \"throw\") {\n                        //   throw new Error(\"File cannot be represented in JSON Schema\");\n                        // }\n                        break;\n                    }\n                    case \"transform\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Transforms cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"nullable\": {\n                        const inner = this.process(def.innerType, params);\n                        _json.anyOf = [inner, { type: \"null\" }];\n                        break;\n                    }\n                    case \"nonoptional\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"success\": {\n                        const json = _json;\n                        json.type = \"boolean\";\n                        break;\n                    }\n                    case \"default\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n                        break;\n                    }\n                    case \"prefault\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        if (this.io === \"input\")\n                            _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n                        break;\n                    }\n                    case \"catch\": {\n                        // use conditionals\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        let catchValue;\n                        try {\n                            catchValue = def.catchValue(undefined);\n                        }\n                        catch {\n                            throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n                        }\n                        _json.default = catchValue;\n                        break;\n                    }\n                    case \"nan\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"NaN cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"template_literal\": {\n                        const json = _json;\n                        const pattern = schema._zod.pattern;\n                        if (!pattern)\n                            throw new Error(\"Pattern not found in template literal\");\n                        json.type = \"string\";\n                        json.pattern = pattern.source;\n                        break;\n                    }\n                    case \"pipe\": {\n                        const innerType = this.io === \"input\" ? (def.in._zod.def.type === \"transform\" ? def.out : def.in) : def.out;\n                        this.process(innerType, params);\n                        result.ref = innerType;\n                        break;\n                    }\n                    case \"readonly\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        _json.readOnly = true;\n                        break;\n                    }\n                    // passthrough types\n                    case \"promise\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"optional\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"lazy\": {\n                        const innerType = schema._zod.innerType;\n                        this.process(innerType, params);\n                        result.ref = innerType;\n                        break;\n                    }\n                    case \"custom\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Custom types cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    default: {\n                        def;\n                    }\n                }\n            }\n        }\n        // metadata\n        const meta = this.metadataRegistry.get(schema);\n        if (meta)\n            Object.assign(result.schema, meta);\n        if (this.io === \"input\" && isTransforming(schema)) {\n            // examples/defaults only apply to output type of pipe\n            delete result.schema.examples;\n            delete result.schema.default;\n        }\n        // set prefault as default\n        if (this.io === \"input\" && result.schema._prefault)\n            (_a = result.schema).default ?? (_a.default = result.schema._prefault);\n        delete result.schema._prefault;\n        // pulling fresh from this.seen in case it was overwritten\n        const _result = this.seen.get(schema);\n        return _result.schema;\n    }\n    emit(schema, _params) {\n        const params = {\n            cycles: _params?.cycles ?? \"ref\",\n            reused: _params?.reused ?? \"inline\",\n            // unrepresentable: _params?.unrepresentable ?? \"throw\",\n            // uri: _params?.uri ?? ((id) => `${id}`),\n            external: _params?.external ?? undefined,\n        };\n        // iterate over seen map;\n        const root = this.seen.get(schema);\n        if (!root)\n            throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n        // initialize result with root schema fields\n        // Object.assign(result, seen.cached);\n        // returns a ref to the schema\n        // defId will be empty if the ref points to an external schema (or #)\n        const makeURI = (entry) => {\n            // comparing the seen objects because sometimes\n            // multiple schemas map to the same seen object.\n            // e.g. lazy\n            // external is configured\n            const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            if (params.external) {\n                const externalId = params.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n                // check if schema is in the external registry\n                const uriGenerator = params.external.uri ?? ((id) => id);\n                if (externalId) {\n                    return { ref: uriGenerator(externalId) };\n                }\n                // otherwise, add to __shared\n                const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;\n                entry[1].defId = id; // set defId so it will be reused if needed\n                return { defId: id, ref: `${uriGenerator(\"__shared\")}#/${defsSegment}/${id}` };\n            }\n            if (entry[1] === root) {\n                return { ref: \"#\" };\n            }\n            // self-contained schema\n            const uriPrefix = `#`;\n            const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n            const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n            return { defId, ref: defUriPrefix + defId };\n        };\n        // stored cached version in `def` property\n        // remove all properties, set $ref\n        const extractToDef = (entry) => {\n            // if the schema is already a reference, do not extract it\n            if (entry[1].schema.$ref) {\n                return;\n            }\n            const seen = entry[1];\n            const { ref, defId } = makeURI(entry);\n            seen.def = { ...seen.schema };\n            // defId won't be set if the schema is a reference to an external schema\n            if (defId)\n                seen.defId = defId;\n            // wipe away all properties except $ref\n            const schema = seen.schema;\n            for (const key in schema) {\n                delete schema[key];\n            }\n            schema.$ref = ref;\n        };\n        // throw on cycles\n        // break cycles\n        if (params.cycles === \"throw\") {\n            for (const entry of this.seen.entries()) {\n                const seen = entry[1];\n                if (seen.cycle) {\n                    throw new Error(\"Cycle detected: \" +\n                        `#/${seen.cycle?.join(\"/\")}/<root>` +\n                        '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n                }\n            }\n        }\n        // extract schemas into $defs\n        for (const entry of this.seen.entries()) {\n            const seen = entry[1];\n            // convert root schema to # $ref\n            if (schema === entry[0]) {\n                extractToDef(entry); // this has special handling for the root schema\n                continue;\n            }\n            // extract schemas that are in the external registry\n            if (params.external) {\n                const ext = params.external.registry.get(entry[0])?.id;\n                if (schema !== entry[0] && ext) {\n                    extractToDef(entry);\n                    continue;\n                }\n            }\n            // extract schemas with `id` meta\n            const id = this.metadataRegistry.get(entry[0])?.id;\n            if (id) {\n                extractToDef(entry);\n                continue;\n            }\n            // break cycles\n            if (seen.cycle) {\n                // any\n                extractToDef(entry);\n                continue;\n            }\n            // extract reused schemas\n            if (seen.count > 1) {\n                if (params.reused === \"ref\") {\n                    extractToDef(entry);\n                    // biome-ignore lint:\n                    continue;\n                }\n            }\n        }\n        // flatten _refs\n        const flattenRef = (zodSchema, params) => {\n            const seen = this.seen.get(zodSchema);\n            const schema = seen.def ?? seen.schema;\n            const _cached = { ...schema };\n            // already seen\n            if (seen.ref === null) {\n                return;\n            }\n            // flatten ref if defined\n            const ref = seen.ref;\n            seen.ref = null; // prevent recursion\n            if (ref) {\n                flattenRef(ref, params);\n                // merge referenced schema into current\n                const refSchema = this.seen.get(ref).schema;\n                if (refSchema.$ref && params.target === \"draft-7\") {\n                    schema.allOf = schema.allOf ?? [];\n                    schema.allOf.push(refSchema);\n                }\n                else {\n                    Object.assign(schema, refSchema);\n                    Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n                }\n            }\n            // execute overrides\n            if (!seen.isParent)\n                this.override({\n                    zodSchema: zodSchema,\n                    jsonSchema: schema,\n                    path: seen.path ?? [],\n                });\n        };\n        for (const entry of [...this.seen.entries()].reverse()) {\n            flattenRef(entry[0], { target: this.target });\n        }\n        const result = {};\n        if (this.target === \"draft-2020-12\") {\n            result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n        }\n        else if (this.target === \"draft-7\") {\n            result.$schema = \"http://json-schema.org/draft-07/schema#\";\n        }\n        else {\n            console.warn(`Invalid target: ${this.target}`);\n        }\n        if (params.external?.uri) {\n            const id = params.external.registry.get(schema)?.id;\n            if (!id)\n                throw new Error(\"Schema is missing an `id` property\");\n            result.$id = params.external.uri(id);\n        }\n        Object.assign(result, root.def);\n        // build defs object\n        const defs = params.external?.defs ?? {};\n        for (const entry of this.seen.entries()) {\n            const seen = entry[1];\n            if (seen.def && seen.defId) {\n                defs[seen.defId] = seen.def;\n            }\n        }\n        // set definitions in result\n        if (params.external) {\n        }\n        else {\n            if (Object.keys(defs).length > 0) {\n                if (this.target === \"draft-2020-12\") {\n                    result.$defs = defs;\n                }\n                else {\n                    result.definitions = defs;\n                }\n            }\n        }\n        try {\n            // this \"finalizes\" this schema and ensures all cycles are removed\n            // each call to .emit() is functionally independent\n            // though the seen map is shared\n            return JSON.parse(JSON.stringify(result));\n        }\n        catch (_err) {\n            throw new Error(\"Error converting schema to JSON.\");\n        }\n    }\n}\nexport function toJSONSchema(input, _params) {\n    if (input instanceof $ZodRegistry) {\n        const gen = new JSONSchemaGenerator(_params);\n        const defs = {};\n        for (const entry of input._idmap.entries()) {\n            const [_, schema] = entry;\n            gen.process(schema);\n        }\n        const schemas = {};\n        const external = {\n            registry: input,\n            uri: _params?.uri,\n            defs,\n        };\n        for (const entry of input._idmap.entries()) {\n            const [key, schema] = entry;\n            schemas[key] = gen.emit(schema, {\n                ..._params,\n                external,\n            });\n        }\n        if (Object.keys(defs).length > 0) {\n            const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            schemas.__shared = {\n                [defsSegment]: defs,\n            };\n        }\n        return { schemas };\n    }\n    const gen = new JSONSchemaGenerator(_params);\n    gen.process(input);\n    return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n    const ctx = _ctx ?? { seen: new Set() };\n    if (ctx.seen.has(_schema))\n        return false;\n    ctx.seen.add(_schema);\n    const schema = _schema;\n    const def = schema._zod.def;\n    switch (def.type) {\n        case \"string\":\n        case \"number\":\n        case \"bigint\":\n        case \"boolean\":\n        case \"date\":\n        case \"symbol\":\n        case \"undefined\":\n        case \"null\":\n        case \"any\":\n        case \"unknown\":\n        case \"never\":\n        case \"void\":\n        case \"literal\":\n        case \"enum\":\n        case \"nan\":\n        case \"file\":\n        case \"template_literal\":\n            return false;\n        case \"array\": {\n            return isTransforming(def.element, ctx);\n        }\n        case \"object\": {\n            for (const key in def.shape) {\n                if (isTransforming(def.shape[key], ctx))\n                    return true;\n            }\n            return false;\n        }\n        case \"union\": {\n            for (const option of def.options) {\n                if (isTransforming(option, ctx))\n                    return true;\n            }\n            return false;\n        }\n        case \"intersection\": {\n            return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n        }\n        case \"tuple\": {\n            for (const item of def.items) {\n                if (isTransforming(item, ctx))\n                    return true;\n            }\n            if (def.rest && isTransforming(def.rest, ctx))\n                return true;\n            return false;\n        }\n        case \"record\": {\n            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n        }\n        case \"map\": {\n            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n        }\n        case \"set\": {\n            return isTransforming(def.valueType, ctx);\n        }\n        // inner types\n        case \"promise\":\n        case \"optional\":\n        case \"nonoptional\":\n        case \"nullable\":\n        case \"readonly\":\n            return isTransforming(def.innerType, ctx);\n        case \"lazy\":\n            return isTransforming(def.getter(), ctx);\n        case \"default\": {\n            return isTransforming(def.innerType, ctx);\n        }\n        case \"prefault\": {\n            return isTransforming(def.innerType, ctx);\n        }\n        case \"custom\": {\n            return false;\n        }\n        case \"transform\": {\n            return true;\n        }\n        case \"pipe\": {\n            return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n        }\n        case \"success\": {\n            return false;\n        }\n        case \"catch\": {\n            return false;\n        }\n        default:\n            def;\n    }\n    throw new Error(`Unknown schema type: ${def.type}`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}